/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.trino.server;

import com.google.common.collect.ImmutableList;
import com.google.common.io.ByteStreams;
import com.google.common.io.Files;
import io.airlift.log.Logger;
import io.trino.spi.Plugin;
import io.trino.spi.classloader.ThreadContextClassLoader;
import org.apache.maven.model.Model;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.AbstractMap.SimpleEntry;
import java.util.Enumeration;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Optional;
import java.util.ServiceLoader;
import java.util.concurrent.Callable;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static io.trino.metadata.FunctionExtractor.extractFunctions;
import static java.util.Arrays.asList;
import static java.util.Objects.requireNonNull;
import static java.util.Objects.requireNonNullElse;

@Command(name = "modulesToConnectors", mixinStandardHelpOptions = true,
        description = "Maps Trino plugin modules to connectors they provide and filters them using a impacted modules list.")
public class PluginReader
        implements Callable<Integer>
{
    private static final Logger log = Logger.get(PluginReader.class);

    @Option(names = {"-i", "--impacted-modules"}, description = "Impacted modules file generated by the gitflow-incremental-builder (GIB) Maven plugin")
    private Optional<File> impactedModulesFile;

    @Option(names = {"-p", "--plugin-dir"}, description = "Trino plugin directory")
    private File pluginDir = new File("plugin");

    @Option(names = {"-r", "--root-pom"}, description = "Trino root module pom.xml")
    private File rootPom = new File("pom.xml");

    public static void main(String... args)
    {
        int exitCode = new CommandLine(new PluginReader()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public Integer call()
    {
        Optional<List<String>> impactedModules = Optional.empty();
        if (impactedModulesFile.isPresent()) {
            impactedModules = readImpactedModules(impactedModulesFile.get());
            if (impactedModules.isEmpty()) {
                return 1;
            }
        }
        Map<String, String> modulesToPlugins = mapModulesToPlugins(rootPom);
        Map<String, Plugin> plugins = loadPlugins(pluginDir).stream()
                .map(plugin -> new SimpleEntry<>(plugin.getClass().getName(), plugin))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        Stream<Map.Entry<String, String>> modulesStream = requireNonNull(modulesToPlugins).entrySet().stream();
        if (impactedModules.isPresent()) {
            boolean hasNonPluginModules = impactedModules.get().stream().anyMatch(module -> !modulesToPlugins.containsKey(module));
            if (hasNonPluginModules) {
                log.warn("Impacted modules list includes non-plugin modules, ignoring it");
            }
            else {
                Optional<List<String>> finalImpactedModules = impactedModules;
                modulesStream = modulesStream.filter(entry -> finalImpactedModules.get().contains(entry.getKey()));
            }
        }

        modulesStream.forEach(entry -> {
            if (!plugins.containsKey(entry.getValue())) {
                log.warn("Plugin without any connectors: %s", entry.getValue());
                return;
            }
            printPluginFeatures(plugins.get(entry.getValue()));
        });
        return 0;
    }

    private static void printPluginFeatures(Plugin plugin)
    {
        plugin.getConnectorFactories().forEach(factory -> System.out.println("connector:" + factory.getName()));
        plugin.getBlockEncodings().forEach(encoding -> System.out.println("blockEncoding:" + encoding.getName()));
        plugin.getTypes().forEach(type -> System.out.println(type.getTypeId()));
        plugin.getParametricTypes().forEach(type -> System.out.println("parametricType:" + type.getName()));
        plugin.getFunctions().forEach(functionClass -> extractFunctions(functionClass)
                .forEach(function -> System.out.println("function:" + function.getFunctionMetadata().getSignature())));
        plugin.getSystemAccessControlFactories().forEach(factory -> System.out.println("systemAccessControl:" + factory.getName()));
        plugin.getGroupProviderFactories().forEach(factory -> System.out.println("groupProvider:" + factory.getName()));
        plugin.getPasswordAuthenticatorFactories().forEach(factory -> System.out.println("passwordAuthenticator:" + factory.getName()));
        plugin.getHeaderAuthenticatorFactories().forEach(factory -> System.out.println("headerAuthenticator:" + factory.getName()));
        plugin.getCertificateAuthenticatorFactories().forEach(factory -> System.out.println("certificateAuthenticator:" + factory.getName()));
        plugin.getEventListenerFactories().forEach(factory -> System.out.println("eventListener:" + factory.getName()));
        plugin.getResourceGroupConfigurationManagerFactories().forEach(factory -> System.out.println("resourceGroupConfigurationManager:" + factory.getName()));
        plugin.getSessionPropertyConfigurationManagerFactories().forEach(factory -> System.out.println("sessionPropertyConfigurationManager:" + factory.getName()));
        plugin.getExchangeManagerFactories().forEach(factory -> System.out.println("exchangeManager:" + factory.getName()));
    }

    private static Map<String, String> mapModulesToPlugins(File rootPom)
    {
        List<String> modules = readTrinoPlugins(rootPom);
        return modules.stream()
                .map(module -> {
                    try (Stream<Path> files = java.nio.file.Files.find(Path.of(requireNonNullElse(rootPom.getParent(), ".") + "/" + module, "target"),
                            1,
                            (path, basicFileAttributes) -> path.toFile().getName().matches(".*-services.jar"))) {
                        Optional<Path> jarFile = files.findFirst();
                        if (jarFile.isPresent()) {
                            return new SimpleEntry<>(module, readPluginClassName(jarFile.get().toFile()));
                        }
                    }
                    catch (IOException e) {
                        log.error(e, "Couldn't read services jar for module %s", module);
                        throw new RuntimeException(e);
                    }
                    throw new MissingResourceException("Couldn't find plugin name in services jar for module %s", Plugin.class.getName(), module);
                })
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    private static List<String> readTrinoPlugins(File rootPom)
    {
        try (FileReader fileReader = new FileReader(rootPom)) {
            MavenXpp3Reader reader = new MavenXpp3Reader();
            Model model = reader.read(fileReader);
            return model.getModules().stream()
                    .filter(module -> isTrinoPlugin(requireNonNullElse(rootPom.getParent(), ".") + "/" + module))
                    .collect(toImmutableList());
        }
        catch (IOException e) {
            log.error(e, "Couldn't read file %s", rootPom);
            throw new RuntimeException(e);
        }
        catch (XmlPullParserException e) {
            log.error(e, "Couldn't parse file %s", rootPom);
            throw new RuntimeException(e);
        }
    }

    private static boolean isTrinoPlugin(String module)
    {
        String modulePom = module + "/pom.xml";
        try (FileReader fileReader = new FileReader(modulePom)) {
            MavenXpp3Reader reader = new MavenXpp3Reader();
            Model model = reader.read(fileReader);
            return model.getPackaging().equals("trino-plugin");
        }
        catch (IOException e) {
            log.error(e, "Couldn't read file %s", modulePom);
            throw new RuntimeException(e);
        }
        catch (XmlPullParserException e) {
            log.error(e, "Couldn't parse file %s", modulePom);
            throw new RuntimeException(e);
        }
    }

    private static String readPluginClassName(File serviceJar)
    {
        try {
            ZipFile zipFile = new ZipFile(serviceJar);
            Enumeration<? extends ZipEntry> e = zipFile.entries();

            while (e.hasMoreElements()) {
                ZipEntry entry = e.nextElement();
                if (entry.isDirectory() || !entry.getName().equals("META-INF/services/io.trino.spi.Plugin")) {
                    continue;
                }
                BufferedInputStream bis = new BufferedInputStream(zipFile.getInputStream(entry));
                String fileContentsStr = new String(ByteStreams.toByteArray(bis), StandardCharsets.UTF_8).trim();
                bis.close();
                return fileContentsStr;
            }
        }
        catch (IOException e) {
            log.error(e, "Couldn't process service JAR %s " + serviceJar);
            throw new RuntimeException(e);
        }
        throw new MissingResourceException("Couldn't find 'META-INF/services/io.trino.spi.Plugin' file in the service JAR %s", Plugin.class.getName(), serviceJar.getPath());
    }

    private static Optional<List<String>> readImpactedModules(File gibImpactedModules)
    {
        try {
            return Optional.of(Files.asCharSource(gibImpactedModules, StandardCharsets.UTF_8).readLines());
        }
        catch (IOException e) {
            log.warn(e, "Couldn't read file %s", gibImpactedModules);
            return Optional.empty();
        }
    }

    private static List<Plugin> loadPlugins(File path)
    {
        ServerPluginsProviderConfig config = new ServerPluginsProviderConfig();
        config.setInstalledPluginsDir(path);
        ServerPluginsProvider pluginsProvider = new ServerPluginsProvider(config, directExecutor());
        ImmutableList.Builder<Plugin> plugins = new ImmutableList.Builder<>();
        pluginsProvider.loadPlugins((plugin, createClassLoader) -> loadPlugin(createClassLoader, plugins), PluginManager::createClassLoader);
        return plugins.build();
    }

    private static void loadPlugin(Supplier<PluginClassLoader> createClassLoader, ImmutableList.Builder<Plugin> plugins)
    {
        PluginClassLoader pluginClassLoader = createClassLoader.get();
        try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(pluginClassLoader)) {
            loadServicePlugin(pluginClassLoader, plugins);
        }
    }

    private static void loadServicePlugin(PluginClassLoader pluginClassLoader, ImmutableList.Builder<Plugin> plugins)
    {
        ServiceLoader<Plugin> serviceLoader = ServiceLoader.load(Plugin.class, pluginClassLoader);
        List<Plugin> loadedPlugins = ImmutableList.copyOf(serviceLoader);
        checkState(!loadedPlugins.isEmpty(), "No service providers of type %s in the classpath: %s", Plugin.class.getName(), asList(pluginClassLoader.getURLs()));
        plugins.addAll(loadedPlugins);
    }
}
